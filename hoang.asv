function hoang()
% Vẽ chữ bằng robot 4DOF + Đồng bộ với robot thực - ĐÃ SỬA LỖI MẶT PHẲNG

close all; clear; clc;

%% ===== CẤU HÌNH HỆ THỐNG =====
sync_mode = true;     % Bật/tắt chế độ đồng bộ với robot thực
com_port = '/dev/ttyUSB0';    % Cổng COM kết nối ESP32-C3
baudrate = 115200;

%% ===== 1. Tạo robot 4DOF từ ETS3 =====
fprintf('1. Khởi tạo mô hình robot...\n');
a1 = 0.12;    % link 1
a2 = 0.118;   % link 2
a3 = 0.083;   % cổ tay + bút
a4 = 0.045;   % link cố định vuông góc

% ETS3 model - SỬA THỨ TỰ KHỚP CHO ĐÚNG
e = ETS3.Rz('q1') * ...    % Khớp base - quay quanh Z
    ETS3.Ry('q2') * ...    % Khớp vai - quay quanh Y  
    ETS3.Tz(a1)   * ...    % Link 1
    ETS3.Ry('q3') * ...    % Khớp khuỷu - quay quanh Y
    ETS3.Tz(a2)   * ...    % Link 2
    ETS3.Ry('q4') * ...    % Khớp cổ tay - quay quanh Y
    ETS3.Tz(a3)   * ...    % Cổ tay
    ETS3.Tx(a4);           % Bút (hướng theo trục X)

arm = ets2rbt(e);
arm.DataFormat = "row";
eeName = arm.BodyNames{end};

% Hiển thị robot
figure;
show(arm, zeros(1,4));
title('Cấu hình Robot 4DOF');
axis equal; grid on;

%% ===== 2. KẾT NỐI ESP32-C3 =====
fprintf('2. Kết nối ESP32-C3...\n');
serialObj = [];
if sync_mode
    [serialObj, connected] = connect_esp32(com_port, baudrate);
    sync_mode = connected;
end

%% ===== 3. ĐƯA ROBOT VỀ HOME =====
fprintf('3. Đưa robot về vị trí home...\n');
% Home position hợp lý hơn
q_home = [0, pi/4, -pi/4, 0]; % Radian - tay hơi gập để tránh singularity

figure;
e.plot(q_home);
title('Robot tại vị trí Home');
axis equal; grid on;

if sync_mode
    send_home_command(serialObj);
end
pause(5);

%% ===== 4. TẠO QUỸ ĐẠO CHỮ TRÊN MẶT PHẲNG NGANG =====
fprintf('4. Tạo quỹ đạo vẽ chữ trên mặt phẳng ngang...\n');
[traj, Tp] = generate_trajectory_fixed();

%% ===== 5. GIẢI ĐỘNG HỌC NGƯỢC =====
fprintf('5. Giải động học ngược...\n');
qj = solve_ik_with_limits_fixed(arm, Tp, eeName);

%% ===== 6. CHUYỂN ĐỔI VÀ GIỚI HẠN GÓC =====
fprintf('6. Chuẩn bị điều khiển robot...\n');
q_degrees = convert_and_limit_angles(qj);

%% ===== 7. MÔ PHỎNG + ĐIỀU KHIỂN ROBOT THỰC =====
fprintf('7. Bắt đầu vẽ chữ...\n');
run_simulation_and_control(e, arm, qj, q_degrees, Tp, eeName, serialObj, sync_mode);

%% ===== 8. KẾT THÚC =====
fprintf('8. Hoàn thành - Đưa robot về home...\n');
if sync_mode
    send_home_command(serialObj);
    clear serialObj;
end
fprintf('=== HOÀN THÀNH ===\n');

end

%% ===== HÀM CON - TẠO QUỸ ĐẠO (ĐÃ SỬA MẶT PHẲNG) =====
function [traj, Tp] = generate_trajectory_fixed()
    load hershey
    ch = 'B';
    B = hershey{ch};
    
    scale = 0.15; % Giảm scale để phù hợp với workspace
    p = [scale * B.stroke; zeros(1, size(B.stroke,2))];
    
    % Xử lý NaN - nâng bút khi chuyển nét
    k = find(isnan(p(1,:)));
    p(:,k) = p(:,k-1);
    penUp = 0.03; % Nâng bút 3cm
    p(3,k) = penUp;
    
    % Đặt mặt phẳng vẽ NGANG tại độ cao thấp hơn base
    % Base robot ở z=0, mặt phẳng vẽ ở z=-0.08m
    %p(3,:) = p(3,:) - 0.08;==========
    
    %dt = 0.03;
    %vmax = [0.02 0.02 0.02]; % Giảm tốc độ
    dt = 0.02;                 % bước thời gian (s)
    vmax = [0.05 0.05 0.05];   % vận tốc tối đa các trục (m/s)
    accTime = 0.2;     

    traj = mstraj(p(:,2:end)', vmax, [], p(:,1)', dt, accTime);
    
    figure;
    plot3(traj(:,1), traj(:,2), traj(:,3), '.-');
    xlabel('x'); ylabel('y'); zlabel('z');
    grid on; axis equal;
    title(['Quỹ đạo đầu bút cho chữ "', ch, '" (frame viết)']);
    
    N = size(traj,1);
    Tp = zeros(4,4,N);
    
    % OFFSET để đặt chữ vào vùng làm việc của robot
    % Dịch chữ về phía trước robot (dọc trục X)
    T_offset = trvec2tform([0.15 0 -0.055]); % 20cm về phía trước
    
    % ORIENTATION QUAN TRỌNG: 
    % End-effector hướng XUỐNG DƯỚI để bút vuông góc với mặt phẳng vẽ
    % Quay 180° quanh trục Y để bút hướng xuống
    T_orient = axang2tform([0 1 0 pi/2]);
    
    for i = 1:N
        T_traj = trvec2tform(traj(i,:));
        Tp(:,:,i) = T_offset * T_traj * T_orient;
    end
end

%% ===== HÀM CON - GIẢI IK VỚI GIỚI HẠN =====
function qj = solve_ik_with_limits_fixed(arm, Tp, eeName)
    ik = inverseKinematics("RigidBodyTree", arm);
    weights = [0 1 0 1 1 1]; % Giảm ưu tiên orientation
    cfg0 = arm.homeConfiguration;
    nJoints = numel(cfg0);
    qj = zeros(N, nJoints);
    for i = 1:N
         [cfgSol, solInfo] = ik(eeName, Tp(:,:,i), weights, cfg0);

         % Lưu nghiệm
         qj(i,:) = cfgSol;

         % Dùng nghiệm hiện tại làm guess cho bước sau để quỹ đạo mượt
         cfg0 = cfgSol;
    end
end

%% ===== HÀM CON - CHUYỂN ĐỔI GÓC =====
function q_degrees = convert_and_limit_angles(qj_rad)
    % Chuyển radian sang độ
    q_degrees = rad2deg(qj_rad);
    
    % GIỚI HẠN GÓC CHO SERVO THỰC TẾ
    servo_limits_deg = [
        45,  135;     % Khớp 1: 45° to 135°
        60,  120;     % Khớp 2: 60° to 120°
        60,  120;     % Khớp 3: 60° to 120°
        60,  120      % Khớp 4: 60° to 120°
    ];
    
    % Áp dụng giới hạn
    for i = 1:size(q_degrees, 1)
        for j = 1:4
            q_degrees(i,j) = max(servo_limits_deg(j,1), ...
                                min(servo_limits_deg(j,2), ...
                                q_degrees(i,j)));
        end
    end
    
    % Hiển thị thông tin góc
    fprintf('   Phạm vi góc khớp (độ):\n');
    for j = 1:4
        fprintf('     Khớp %d: %.1f° → %.1f°\n', ...
                j, min(q_degrees(:,j)), max(q_degrees(:,j)));
    end
end

%% ===== HÀM CON - KẾT NỐI ESP32 =====
function [serialObj, success] = connect_esp32(port, baudrate)
    success = false;
    serialObj = [];
    
    try
        serialObj = serialport(port, baudrate);
        configureTerminator(serialObj, "LF");
        pause(2);
        
        % Kiểm tra kết nối
        writeline(serialObj, "PING");
        pause(0.5);
        
        if serialObj.NumBytesAvailable > 0
            response = readline(serialObj);
            if contains(response, "PONG")
                fprintf('   Kết nối ESP32-C3 thành công!\n');
                success = true;
            end
        end
    catch ME
        fprintf('   Lỗi kết nối: %s\n', ME.message);
    end
end

%% ===== HÀM CON - MÔ PHỎNG VÀ ĐIỀU KHIỂN =====
function run_simulation_and_control(e, arm, qj, q_degrees, Tp, eeName, serialObj, sync_mode)
    figure('Position', [100 100 1200 800]);
    
    % Mô phỏng robot
    e.plot(qj(1,:));
    ax = gca;
    view(ax, 45, 30);
    grid on; axis equal; hold on;
    
    % Vẽ quỹ đạo mong muốn
    X = squeeze(Tp(1,4,:));
    Y = squeeze(Tp(2,4,:));
    Z = squeeze(Tp(3,4,:));
    plot3(X, Y, Z, 'm-', 'LineWidth', 2, 'DisplayName', 'Quỹ đạo mong muốn');
    
    % Vệt bút thực tế
    trail = animatedline('LineWidth', 3, 'Color', 'red', 'DisplayName', 'Vệt bút thực');
    
    % Vẽ mặt phẳng vẽ
    [x_plane, y_plane] = meshgrid(0.1:0.05:0.3, -0.1:0.05:0.1);
    z_plane = -0.08 * ones(size(x_plane));
    surf(x_plane, y_plane, z_plane, 'FaceAlpha', 0.2, 'FaceColor', 'blue', 'EdgeColor', 'none');
    
    legend;
    title('Robot 4DOF Vẽ Chữ "B" - Đồng Bộ Mô Phỏng và Thực Tế');
    xlabel('X (m)'); ylabel('Y (m)'); zlabel('Z (m)');
    
    r = rateControl(20);
    
    fprintf('   Bắt đầu vẽ...\n');
    
    for i = 1:size(qj, 1)
        % Mô phỏng
        e.animate(qj(i,:));
        Tee = getTransform(arm, qj(i,:), eeName);
        addpoints(trail, Tee(1,4), Tee(2,4), Tee(3,4));
        
        % Robot thực
        if sync_mode && ~isempty(serialObj)
            send_joint_angles(serialObj, q_degrees(i,:));
        end
        
        if mod(i, 30) == 0
            fprintf('   Điểm %d/%d\n', i, size(qj, 1));
        end
        
        drawnow limitrate;
        r.waitfor;
    end
end

%% ===== HÀM GIAO TIẾP =====
function send_joint_angles(serialObj, q_degrees)
    cmd = sprintf("MOVETO %.1f %.1f %.1f %.1f", q_degrees);
    writeline(serialObj, cmd);
end

function send_home_command(serialObj)
    writeline(serialObj, "HOME");
    fprintf('   Đã gửi lệnh HOME đến robot thực\n');
    pause(3);
end